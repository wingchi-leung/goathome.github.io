<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="C语言库函数strtok123#include &lt;string.h&gt;  char * strtok(char *s, const char *delim);   功能：用来将字符串分割成一个一个片段，参数s指向欲分割的字符串，delim则为分割字符串， （只需要遇到delim字符串中其中一个字符）   在参数s 的字符串中发现到参数delim 的分割字符时则会将该字符改为\0 字符">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://wingchi-leung.github.io/goat-iceam.github.io/2021/07/26/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="C语言库函数strtok123#include &lt;string.h&gt;  char * strtok(char *s, const char *delim);   功能：用来将字符串分割成一个一个片段，参数s指向欲分割的字符串，delim则为分割字符串， （只需要遇到delim字符串中其中一个字符）   在参数s 的字符串中发现到参数delim 的分割字符时则会将该字符改为\0 字符">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="d:/Typora/LinuxIO编程.assets/image-20210526175119793.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2020120100082154.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1hfTXJqdw==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://images0.cnblogs.com/i/448111/201403/181615186626017.jpg">
<meta property="og:image" content="https://pic3.zhimg.com/80/v2-c2aca533a7dbdee6c69f5116578d2436_1440w.jpg">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/16823531-baf6c22c59b827fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/685">
<meta property="og:image" content="https://img-blog.csdn.net/20180807210110732?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDEwNzMw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">
<meta property="og:image" content="https://images0.cnblogs.com/blog2015/570460/201507/041632598968698.png">
<meta property="og:image" content="https://images0.cnblogs.com/blog/413416/201402/250221581092754.png">
<meta property="og:image" content="http://c.biancheng.net/cpp/uploads/allimg/140901/1-140Z11I213549.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200504135556323.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ptaWxr,size_16,color_FFFFFF,t_70">
<meta property="article:published_time" content="2021-07-26T02:03:04.455Z">
<meta property="article:modified_time" content="2021-07-04T08:41:20.433Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="d:/Typora/LinuxIO编程.assets/image-20210526175119793.png">
  
    <link rel="alternate" href="/goat-iceam.github.io/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/goat-iceam.github.io/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/goat-iceam.github.io/css/style.css">

  
    
<link rel="stylesheet" href="/goat-iceam.github.io/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/goat-iceam.github.io/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/goat-iceam.github.io/">Home</a>
        
          <a class="main-nav-link" href="/goat-iceam.github.io/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/goat-iceam.github.io/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://wingchi-leung.github.io/goat-iceam.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-Linux系统编程" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/goat-iceam.github.io/2021/07/26/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/" class="article-date">
  <time class="dt-published" datetime="2021-07-26T02:03:04.455Z" itemprop="datePublished">2021-07-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="C语言库函数"><a href="#C语言库函数" class="headerlink" title="C语言库函数"></a>C语言库函数</h2><h3 id="strtok"><a href="#strtok" class="headerlink" title="strtok"></a>strtok</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">char</span> * <span class="title">strtok</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">const</span> <span class="keyword">char</span> *delim)</span></span>; </span><br></pre></td></tr></table></figure>

<p>功能：用来将字符串分割成一个一个片段，参数s指向欲分割的字符串，delim则为分割字符串， （只需要遇到delim字符串中其中一个字符） </p>
<p> 在参数s 的字符串中发现到参数delim 的分割字符时则会将该字符改为\0 字符 </p>
<p> 在第一次调用时，strtok()必需给予参数s 字符串，往后的调用则将参数s 设置成NULL。每次调用成功则返回下一个分割后的字符串指针。</p>
<p>返回值：返回下一个分割后的字符串指针，如果已无从分割则返回NULL。 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;string.h&gt;</span><br><span class="line">main()&#123;</span><br><span class="line">    char s[] = &quot;ab-cd : ef;gh :i-jkl;mnop;qrs-tu: vwx-y;z&quot;;</span><br><span class="line">    char *delim = &quot;-: &quot;;</span><br><span class="line">    char *p;</span><br><span class="line">    printf(&quot;%s &quot;, strtok(s, delim));</span><br><span class="line">    while((p = strtok(NULL, delim)))</span><br><span class="line">        printf(&quot;%s &quot;, p);</span><br><span class="line">        printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">执行结果：</span><br><span class="line">ab cd ef;gh i jkl;mnop;qrs tu vwx y;z     //－与:字符已经被\0 字符取代</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="strchr"><a href="#strchr" class="headerlink" title="strchr"></a>strchr</h3><p>用于查找给定字符串中的某一个特定字符串</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strchr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*str, <span class="keyword">int</span> c)</span> </span>;</span><br><span class="line">str被查找的字符串</span><br><span class="line">c 要查找的字符</span><br></pre></td></tr></table></figure>

<p> strchr() 函数会依次检索字符串 str 中的每一个字符，直到遇见字符 c，或者到达字符串末尾（遇见<code>\0</code>）。</p>
<p>返回值：返回在字符串 str 中第一次出现字符 c 的位置，如果未找到该字符 c 则返回 NULL。 </p>
<p>abc\n   3 </p>
<h3 id="isspace"><a href="#isspace" class="headerlink" title="isspace"></a>isspace</h3><p><code>int isspace (int c)</code></p>
<p>判断字符是否为空白符 </p>
<p>返回值： 非零表示是空白符 ， 0 表示不是空白符 </p>
<h2 id="c语言基础"><a href="#c语言基础" class="headerlink" title="c语言基础"></a>c语言基础</h2><h3 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h3><p>main函数原型：</p>
<p><code>int main(int argc,char *argv[], char * envp[]);</code></p>
<p> ①  第一个参数argc 表示的是传入参数的个数</p>
<p> ② 第二个参数 char *argv[] 是字符串数组，用来存放指向字符串参数的指针数组，没有给元素指向一个参数，各个成员含义：</p>
<p>argv[0] 指向程序运行的全路径名</p>
<p>argv[1] 指向程序名后的第一个字符串，表示真正传入的第一个参数</p>
<p>… argv[2] , argv[n] 是传入的第i个参数</p>
<p><strong>规定grav[argc] 为NULL，表示参数的结尾</strong></p>
<p>③、第三个参数char* envp[]，也是一个字符串数组，主要是保存这用户环境中的变量字符串，以NULL结束。envp[]的每一个元素都包含ENVVAR=value形式的字符串，其中ENVVAR为环境变量，value为其对应的值。envp一旦传入，它就只是单纯的字符串数组而已，不会随着程序动态设置发生改变。可以使用putenv函数实时修改环境变量，也能使用getenv实时查看环境变量，但是envp本身不会发生改变；平时使用到的比较少。</p>
<h3 id="多文件编译"><a href="#多文件编译" class="headerlink" title="多文件编译"></a>多文件编译</h3><h3 id="结构体，typedef"><a href="#结构体，typedef" class="headerlink" title="结构体，typedef"></a>结构体，typedef</h3><p>定义一个名字为TreeNode的结构体类型（没有定义结构体变量，并不占用内存空间）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="keyword">int</span> Element;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">LeftChild</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">RightChild</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> <span class="title">Node</span>;</span>  </span><br><span class="line"><span class="comment">// 为结构体起一个别名Node，这时Node就等价于struct TreeNode</span></span><br></pre></td></tr></table></figure>

<p>使用typedef关键字定义结构体类型    定义结构体类型的同时定义结构体类型变量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="keyword">int</span> age;</span><br><span class="line">        <span class="keyword">int</span> height;</span><br><span class="line">&#125;<span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//std相当于struct student</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="keyword">int</span> age;</span><br><span class="line">        <span class="keyword">int</span> height;</span><br><span class="line">&#125;std1,std2;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义了student数据类型的结构体和std1、std2结构体变量</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="keyword">int</span> Element;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">LeftChild</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">RightChild</span>;</span></span><br><span class="line">&#125; *PtrToTreeNode;               <span class="comment">//直接定义指针 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="keyword">int</span> Element;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">LeftChild</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">RightChild</span>;</span></span><br><span class="line">&#125; PNode ,*PtrToTreeNode;               <span class="comment">//直接定义指针 </span></span><br><span class="line"><span class="comment">// 这样既起了别名，又定义了指针</span></span><br><span class="line">PNode是别名</span><br></pre></td></tr></table></figure>

<h3 id="计算程序运行时间"><a href="#计算程序运行时间" class="headerlink" title="计算程序运行时间"></a>计算程序运行时间</h3><ol>
<li><p>使用time命令</p>
<p><code>#time ./a.out</code> </p>
</li>
<li><p>使用clock函数统计时间</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span>           </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span>               <span class="comment">/*要包含的头文件*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* Init  */</span></span><br><span class="line">    <span class="keyword">clock_t</span> start, end;</span><br><span class="line">    start = clock();           <span class="comment">/*记录起始时间*/</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;time calc test\n&quot;</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * 函数进行的一些列操作</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Final Status */</span></span><br><span class="line">    end = clock();           <span class="comment">/*记录结束时间*/</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> seconds  =(<span class="keyword">double</span>)(end - start)/CLOCKS_PER_SEC;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Use time is: %.8f\n&quot;</span>, seconds);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>clock()函数为最常用的计时函数，返回end与begin之间的CPU时钟计时单元数（clock tick）,当进行单线程或者单核心运行时，可以使用clock()统计，但使用多线程运行时，clock()计时会引发问题，这是因为clock()在多线程返回的是end-begin的多个核心总共执行的时钟嘀嗒数，所以造成时间偏大。</p>
<h4 id="用timeval"><a href="#用timeval" class="headerlink" title="用timeval"></a>用timeval</h4><h3 id="动态初始化二维数组"><a href="#动态初始化二维数组" class="headerlink" title="动态初始化二维数组"></a>动态初始化二维数组</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/majinfei/article/details/16942989">https://blog.csdn.net/majinfei/article/details/16942989</a></p>
<h2 id="Linux命令"><a href="#Linux命令" class="headerlink" title="Linux命令"></a>Linux命令</h2><h3 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h3><p>tar [选项]  源文件或目录</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>-c</td>
<td>将多个文件或目录进行打包。</td>
</tr>
<tr>
<td>-A</td>
<td>追加 tar 文件到归档文件。</td>
</tr>
<tr>
<td>-f 包名</td>
<td>指定包的文件名。包的扩展名是用来给管理员识别格式的，所以一定要正确指定扩展名；</td>
</tr>
<tr>
<td>-v</td>
<td>显示打包文件过程；</td>
</tr>
</tbody></table>
<p><code>tar  -cvf   student.txt.tar  student.txt </code></p>
<p>压缩之前必须先打包，再用gzip或bzip2命令对打包文件进行压缩</p>
<h4 id="解打"><a href="#解打" class="headerlink" title="解打"></a>解打</h4><p>-c: 建立压缩档案<br> -x：解压<br> -t：查看内容<br> -r：向压缩归档文件末尾追加文件<br> -u：更新原压缩包中的文件</p>
<h3 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ps - ef | grep java </span><br><span class="line">表示查看所有进程里名字带有java的进程</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="批量杀死进程"><a href="#批量杀死进程" class="headerlink" title="批量杀死进程"></a>批量杀死进程</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kill -9  `ps -ef | grep &lt;name&gt;` </span><br><span class="line">grep是搜索</span><br><span class="line">被kill的进程有共同的字符串</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="vi"><a href="#vi" class="headerlink" title="vi"></a>vi</h3><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>多行删除，删除1到10行</p>
<p><code>：1,10d</code></p>
<p>从某行开始至文本末尾全部删除，删除第8行至末尾</p>
<p><code>：8，$d</code></p>
<p>单行删除：1（待删除行）d</p>
<p>光标所在行，dd</p>
<h4 id="复制粘贴"><a href="#复制粘贴" class="headerlink" title="复制粘贴"></a>复制粘贴</h4><ol>
<li><p>选定文本块。使用v进入可视模式，移动光标键选定内容。</p>
</li>
<li><p>复制的命令是y，即yank（提起） ，常用的命令如下：</p>
<pre><code>y      在使用v模式选定了某一块的时候，复制选定块到缓冲区用；
yy    复制整行（nyy或者yny ，复制n行，n为数字）；
y^   复制当前到行头的内容；
y$    复制当前到行尾的内容；
yw   复制一个word （nyw或者ynw，复制n个word，n为数字）；
yG    复制至档尾（nyG或者ynG，复制到第n行，例如1yG或者y1G，复制到档尾） 
</code></pre>
</li>
<li><p>剪切的命令是d，即delete，d与y命令基本类似，所以两个命令用法一样，包括含有数字的用法.<br>d      剪切选定块到缓冲区；<br>dd    剪切整行<br>d^    剪切至行首<br>d$     剪切至行尾<br>dw    剪切一个word<br>dG     剪切至档尾 </p>
</li>
<li><p>粘贴的命令式p，即put（放下）<br> p   小写p代表贴至游标后（下），因为游标是在具体字符的位置上，所以实际是在该字符的后面<br> P   大写P代表贴至游标前（上）<br> 整行的复制粘贴在游标的上（下）一行，非整行的复制则是粘贴在游标的前（后） </p>
</li>
</ol>
<h2 id="LinuxIO编程"><a href="#LinuxIO编程" class="headerlink" title="LinuxIO编程"></a>LinuxIO编程</h2><p><img src="D:\Typora\LinuxIO编程.assets\image-20210526175119793.png" alt="image-20210526175119793"></p>
<p>内核为每个进程维护一个打开文件的列表file table，文件表由一些非负整数进行索引； 这些非负整数称为文件描述符（file descriptors ，fds）列表的每一项都是一个打开文件的信息，包括指向该文件的索引节点（inode）内存拷贝的指针以及相关联的元数据，入文件位置指针和访问模式</p>
<p>每个进程创建时，都默认打开三个文件：标准输入设备、标准输出设备、标准错误输出设备，这三个文件的file结构体地址登记在文件描述符表前三项，其文件描述符分别是0，1，2其宏定义为：</p>
<p>#define <strong>STDIN_FILENO</strong> 0</p>
<p>#define <strong>STDOUT_FILENO</strong> 1</p>
<p>#define <strong>STDERR_FILENO</strong> 2</p>
<h3 id="open"><a href="#open" class="headerlink" title="open()"></a>open()</h3><p>需要三个头文件：</p>
<p>#include &lt;sys/types.h&gt;</p>
<p>#include &lt;sys/stat.h&gt;</p>
<p>#include &lt;fcntl.h&gt;</p>
<p><code>int open(const char* name,int flags)</code></p>
<p><code>int open(const char* name, int flags,mode_t mode) </code></p>
<p>返回值：如果执行成功则返回文件描述符 </p>
<p><strong>参数：</strong></p>
<ul>
<li><p><strong>flags:</strong> 使用什么方式打开指定的文件，这个参数对应一些宏值，需要根据实际需求指定</p>
</li>
<li><p>必须要指定的属性 , 以下三个属性不能同时使用，只能任选其一<br><strong>O_RDONLY: 以只读方式打开文件</strong><br><strong>O_WRONLY: 以只写方式打开文件</strong><br><strong>O_RDWR: 以读写方式打开文件</strong></p>
</li>
<li><p>可选属性 , 和上边的属性一起使用</p>
</li>
</ul>
<ol>
<li><strong>O_APPEND:</strong> 新数据追加到文件尾部，不会覆盖文件的原来内容</li>
<li><strong>O_CREAT</strong>: 如果文件不存在，创建该文件，如果文件存在什么也不</li>
<li><strong>O_EXCL</strong>: 检测文件是否存在，必须要和 O_CREAT 一起使用</li>
</ol>
<p>不能单独使用: O_CREAT 或 O_EXCL</p>
<ul>
<li><p><strong>mode:</strong> 在创建新文件的时候才需要指定这个参数的值，用于指定新文件的权限，这是一个八进制的整数</p>
</li>
<li><p>创建的新文件对应的最终实际权限，计算公式: (mode &amp; ~umask)  umask先取反再和mode按位与</p>
<p>umask 掩码可以通过 umask 命令查看 </p>
</li>
</ul>
<h3 id="fopen"><a href="#fopen" class="headerlink" title="fopen"></a>fopen</h3><p>FILE *fopen(const char *path,const char *mode) ;</p>
<p> mode：文件打开方式</p>
<table>
<thead>
<tr>
<th align="left">模式</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">“b”</td>
<td align="center">二进制文件</td>
</tr>
<tr>
<td align="left">“r”</td>
<td align="center">打开一个用于读取的文件。该文件必须存在。</td>
</tr>
<tr>
<td align="left">“w”</td>
<td align="center">创建一个用于写入的空文件。如果文件名称与已存在的文件相同，则会删除已有文件的内容，文件被视为一个新的空文件。</td>
</tr>
<tr>
<td align="left">“a”</td>
<td align="center">追加到一个文件。写操作向文件末尾追加数据。如果文件不存在，则创建文件。</td>
</tr>
<tr>
<td align="left">“r+”</td>
<td align="center">打开一个用于更新的文件，可读取也可写入。该文件必须存在。</td>
</tr>
<tr>
<td align="left">“w+”</td>
<td align="center">创建一个用于读写的空文件。</td>
</tr>
<tr>
<td align="left">“a+”</td>
<td align="center">打开一个用于读取和追加的文件。</td>
</tr>
</tbody></table>
<h3 id="write"><a href="#write" class="headerlink" title="write()"></a>write()</h3><p>包含头文件： &lt;unistd.h&gt;</p>
<p>函数定义：ssize_t write (int fd, const void * buf, size_t count); </p>
<p>ssize_t 为有符号整型； size_t 是无符号整型</p>
<p>函数说明：write()会把参数buf所指的内存写入count个字节到参数fd所指的文件内。</p>
<p>返回值：如果顺利write()会返回实际写入的字节数（len）。当有错误发生时则返回-1，错误代码存入errno中。当write第三个参数为0时返回0</p>
<p>write() 函数从buf写入到文件中，若buf数据无法一次性读完，那么第二次读buf数据时，buf的位置指针不会自动移动，需要程序员控制，可以按照如下格式进行移动：</p>
<p><code>write(fp,p+len,(strlen(p-len))</code></p>
<h3 id="rewind"><a href="#rewind" class="headerlink" title="rewind"></a>rewind</h3><p>头文件：#include&lt;stdio.h&gt;</p>
<p>void  rewind(FILE *stream)</p>
<p>用于将文件指针重新指向文件的开头，同时清除和文件相关的错误和eof标记，相当于调用fseek(stream , 0, SEEK_SET) </p>
<h3 id="fwrite"><a href="#fwrite" class="headerlink" title="fwrite"></a>fwrite</h3><p>fwrite() 是 C 语言标准库中的一个文件处理函数，功能是向指定的文件中写入若干数据块，如成功执行则返回实际写入的数据块数目。<strong>该函数以二进制形式对文件进行操作，不局限于文本文件。</strong></p>
<p>头文件：stdio.h</p>
<p>函数原型：size_t fwrite(const void* buffer, size_t size, size_t count, FILE* stream);<br>（1）buffer：是一个指针，对fwrite来说，是要获取数据的地址；<br>（2）size：要写入内容的单字节数；<br>（3）count:要进行写入size字节的数据项的个数；<br>（4）stream:目标文件指针；<br>（5）返回实际写入的数据项个数count。<br>说明：写入到文件的哪里？ 这个与文件的打开模式有关，如果是w+，则是从file pointer指向的地址开始写，替换掉之后的内容，文件的长度可以不变，stream的位置移动count个数；如果是a+，则从文件的末尾开始添加，文件长度加大。<br>fseek对此函数有作用，但是fwrite 函数写到用户空间缓冲区，*<em>并未同步到文件中，所以修改后要将内存与文件同步可以用fflush（FILE <em>fp）函数同步。</em></em></p>
<p>注意：返回值随着调用格式的不同而不同：</p>
<h3 id="fread"><a href="#fread" class="headerlink" title="fread"></a>fread</h3><p>头文件：#include &lt;stdio.h&gt;</p>
<p> fread()函数用于从文件流中读取数据，其原型为：<br>   size_t  fread(void *buffer, size_t size, size_t count, FILE * stream);</p>
<p> 【参数】buffer为接收数据的地址，size为一个单元的大小，count为单元个数，stream为文件流。</p>
<p> fread()函数每次从stream中最多读取count个单元，每个单元大小为size个字节，将读取的数据放到buffer；文件流的位置指针后移 size * count 字节。</p>
<p> 【返回值】返回实际读取的单元个数。如果小于count，则可能文件结束或读取出错；可以用ferror()]检测是否读取出错，用feof()函数检测是否到达文件结尾。如果size或count为0，则返回0。</p>
<h3 id="fgets"><a href="#fgets" class="headerlink" title="fgets"></a>fgets</h3><blockquote>
<p> 虽然用 gets() 时有空格也可以直接输入，但是 gets() 有一个非常大的缺陷，即它不检查预留存储区是否能够容纳实际输入的数据，换句话说，如果输入的字符数目大于数组的长度，gets 无法检测到这个问题，就会发生内存越界，所以编程时建议使用 fgets()。</p>
</blockquote>
<p><code>char *fget(char *s, int n, FILE *stream) </code></p>
<p>参数 ：</p>
<p>s：字符型指针，指向数据的缓冲区的地址</p>
<p>n：从 流中读入 n-1个字符，并在最后加上’\n’</p>
<p>stream：指向读取的流</p>
<p>返回值：</p>
<ol>
<li><p>当n&lt;=0 时返回NULL</p>
</li>
<li><p>当n=1 时返回空串   “”</p>
</li>
<li><p>如果读入成功，则返回缓冲区的地</p>
</li>
</ol>
<h3 id="fputs"><a href="#fputs" class="headerlink" title="fputs"></a>fputs</h3><p>int fputs(const char*s , FILE *stream)</p>
<ol>
<li>使用 puts() 时，系统会在自动在其后添加换行符；而使用 fputs() 时，系统不会自动添加换行符。</li>
</ol>
<h3 id="fscanf"><a href="#fscanf" class="headerlink" title="fscanf()"></a>fscanf()</h3><p><code>int fscanf(FILE *stream,char *format ,[arg1,arg2...]) </code></p>
<p>从流中执行格式化输入，<strong>遇到空格或换行结束</strong></p>
<h3 id="fprintf"><a href="#fprintf" class="headerlink" title="fprintf()"></a>fprintf()</h3><p><code>int fprintf(FILE *stream, const char *format ,[,arg..])</code></p>
<p> fprintf（fp, “%s %s %d %f”, str1,str2, a, b） ; </p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p><strong>ftell（）函数：</strong>得到流式文件的当前读写位置，其返回值是当前读写位置偏离文件头部的字节数。</p>
<p>*<em>原型：long ftell（FILE <em>fp）</em></em></p>
<h1 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h1><p>进程包括二进制镜像，加载到内存中，等等很多方面。</p>
<p>PID进程标识， 父进程标识PPID，用户表示UID，组标识GID等信息</p>
<h2 id="运行新进程"><a href="#运行新进程" class="headerlink" title="运行新进程"></a>运行新进程</h2><p>在unix中，把程序载入内存并执行程序映像操作与创建新进程的操作是分开的，一次系统调用会把二进制程序加载到内存中，替换地址空间原来的内容，并开始执行，这个过程叫做executing（执行）</p>
<p><code>int execl(const char*path,const char *arg,....)</code>   l就表示list的意思</p>
<p>把path指定的路径的映像载入内存，替换当前进程的映像，参数arg是他的第一个参数，后面的 … 表示可变长度的参数列表，表示后面还有一个或多个参数</p>
<p>调用成功一般不会返回，会转到新的程序入口点，而刚刚运行的代码不再存在于进程的地址空间中，错误时会返回-1，并设置errno值，表示错误信息。</p>
<p>成功调用的execl() 不仅该改变了地址空间和进程映像 </p>
<p>　当进程调用一种exec函数时，该进程完全由新程序代换，而新程序则从其main函数开始执行。因为调用exec并不创建新进程，所以前后的进程ID并未改变。exec只是用另一个新程序替换了当前进程的正文、数据、堆和栈段。</p>
<h3 id="exec系函数"><a href="#exec系函数" class="headerlink" title="exec系函数"></a>exec系函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execlp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*file,<span class="keyword">const</span> <span class="keyword">char</span> *arg ,....)</span> </span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execle</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*path,<span class="keyword">const</span> <span class="keyword">char</span> *arg ,.... , <span class="keyword">char</span> * <span class="keyword">const</span> envp[])</span> </span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*path, <span class="keyword">char</span> * <span class="keyword">const</span> argv[] ,....)</span> </span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execve</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*filename,<span class="keyword">const</span> <span class="keyword">char</span> argv[] , <span class="keyword">char</span> *<span class="keyword">const</span> envp[]....)</span> </span>;</span><br><span class="line"></span><br><span class="line">l (<span class="built_in">list</span>)                           命令行参数列表</span><br><span class="line"></span><br><span class="line">p (path)                       搜素file时使用path变量</span><br><span class="line"></span><br><span class="line">v (<span class="built_in">vector</span>)                    使用命令行参数数组</span><br><span class="line"></span><br><span class="line">e (environment)       使用环境变量数组,不使用进程原有的环境变量，设置新加载程序运行的环境变量</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>带l的函数：execl，execlp，execle </p>
<p>具体说明：表示后边的参数以可变参数的形式给出且都以一个空指针结束。这里特别要说明的是，程序名也是参数，所以第一个参数就是程序名。</p>
<p><code>execl(&quot;/bin/ls&quot;, &quot;ls&quot;, NULL);</code></p>
<p><strong>带p的exec函数</strong></p>
<p>这类函数有：execlp，execvp</p>
<p><code>int execvp(const char *file, char * const argv []);</code></p>
<p>具体说明：表示第一个参数无需给出具体的路径，只需给出函数名即可，系统会在PATH环境变量中寻找所对应的程序，如果没找到的话返回－1。</p>
<p><code>execlp(&quot;ls&quot;, &quot;ls&quot;, &quot;-l&quot;, NULL);</code></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/yychuyu/article/details/80173039">https://blog.csdn.net/yychuyu/article/details/80173039</a></p>
<h2 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h2><h3 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h3><p>fork函数为已经存在的进程创建一个新的进程，而这个新创建出来的进程称为原进程的子进程``</p>
<p><code>#include &lt;unistd.h&gt;</code></p>
<p><code>pid_t fork(void)</code>  <strong>该函数返回两个值</strong> <strong>子进程返回0，父进程返回子进程的pid</strong>， 如果出错，则返回-1 (pid_t 其实就是int，在内核中通过typedef重命名) </p>
<p>子进程会复制父进程的pcb，二者之前代码共享，数据独有，拥有各自的进程虚拟地址空间。 </p>
<blockquote>
<p>疑问：既然代码共享，子进程又拷贝了父进程的PCB，虽然他们各自拥有自己的进程虚拟地址空间，但其中的数据必然是相同的（拷贝而来），并且通过页表映射到同一块物理内存中，那么又如何做到数据独有呢？答案是：<strong>通过写时拷贝技术。</strong></p>
</blockquote>
<p>写拷贝技术：子进程创建出来后，与父进程映射访问同一块物理内存，但当父子进程当中任意一个进程改变了内存中的数据时，会给子进程重新在物理内存中开辟一块空间，并将数据拷贝过去，这样避免了直接给子进程重新开辟内存空间，造成数据冗余。<strong>如果父子进程都不更改内存中的值，那他们两个各自的进程虚拟地址空间通过页表映射，始终是指向同一块物理内存</strong> </p>
<h3 id="vfork"><a href="#vfork" class="headerlink" title="vfork"></a>vfork</h3><p><code>#include &lt;unistd.h&gt;</code></p>
<p><code>pid_t vfork(void);</code></p>
<p>和fork的区别： 子进程和父进程共享同一个进程虚拟地址空间</p>
<p>会导致混乱： 比如说父进程调用函数fun()先压栈，后子进程调用test()压栈，导致fun无法返回</p>
<p>解决：一个进程运行的时候另一个阻塞 ， 效率不高， 逐渐被fork取代</p>
<h3 id="进程终止"><a href="#进程终止" class="headerlink" title="进程终止"></a>进程终止</h3><p>进程退出的场景：</p>
<ol>
<li>程序运行完毕，从main函数退出</li>
<li>调用eixt函数 <code>#include &lt;stdlib.h&gt;  void exit(int status )</code> 库函数，内部封装系统调用</li>
<li>调用_exit函数    系统调用函数</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/2020120100082154.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1hfTXJqdw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>exit()与_exit()还有一个很重要的区别就是在退出前会不会刷新缓冲区。显然，前者是会刷新缓冲区的</strong>，这也是它在封装后者的基础上所增加了一些后者并不具备的功能。</p>
<h2 id="进程等待"><a href="#进程等待" class="headerlink" title="进程等待"></a>进程等待</h2><p>进程终止以后，将大部分资源还给了系统，但仍占用进程pid，保留其进程控制块PCB，其中包含退出状态和一些对父进程有用的信息，等待父进程读取和处理。</p>
<p>子进程终止时，会向父进程发送一个通知信号，父进程可执行函数<code>waitpid</code> 对其进行清理</p>
<p><strong>如果子进程先于父进程退出，而父进程并没有关心子进程的退出状况，从而无法回收子进程的资源，就会导致子进程变成僵尸进程。</strong></p>
<blockquote>
<p>如果对信号有一定的了解，就会知道，僵尸进程一旦产生就算是kill-9这样的强杀信号都杀不掉它，因为谁也没办法杀掉一个已经死去的进程！ 那怎么办呢？当时在进程概念的位置并没有提解决（避免）僵尸进程的办法，而在这个位置再次说到它，就是想来引出进程等待这个概念。<strong>进程等待的作用就是防止僵尸进程的产生</strong></p>
</blockquote>
<p><code>pid_t waitpid(pid_t pid, int *status, int options)</code></p>
<p><code>pit_t wait(int * status) ;</code></p>
<p><strong>返回值</strong>：成功会返回被等待进程的pid，失败则会返回-1</p>
<p><strong>参数</strong>：一级指针status，它其实是个输出型参数，用于获取子进程的退出状态，如果不关心则可以设置为NULL</p>
<h2 id="进程控制-1"><a href="#进程控制-1" class="headerlink" title="进程控制"></a>进程控制</h2><p>linux系统启动时，生成一个init进程，pid=1，称为初始化进程，是其他所有进程的祖先进程，其他进程都是由init进程或其子孙进程创建的</p>
<h2 id="加载函数"><a href="#加载函数" class="headerlink" title="加载函数"></a>加载函数</h2><p><code>#include &lt;unistd.h&gt;</code></p>
<p><code>int execve(const char*filename,const char * )</code></p>
<h1 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h1><p>进程通信： IPC  Inter-Process Communication</p>
<p>管道是单向的，先进先出的，他把一个进程的输出和另一个进程的输入连接在一起，一个进程（写进程）在管道的尾部写入数据，另一个进程（读进程）从管道的头部读出进程。</p>
<blockquote>
<p>数据被一个进程读出后，将从管道中删除，其他读进程将不能在读到这些数据。进程试图<strong>读空进程</strong>或者<strong>写满进程</strong>的话， 都会阻塞。 </p>
</blockquote>
<p>管道分为无名管道和命名管道，前者用在父进程和子进程间的通信，后者用于任意进程间通信 </p>
<blockquote>
<p>当进程创建管道时，每次</p>
<p>都需要提供两个文件描述符来操作管道。其中一个对管道进行写操作，另一个对管道进行读操作。对管道的读写与一般的IO系统函数一</p>
<p>致，使用write()函数写入数据，使用read()读出数据。</p>
</blockquote>
<p><img src="https://images0.cnblogs.com/i/448111/201403/181615186626017.jpg" alt="img"></p>
<h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p><code>#include &lt;unistd.h&gt;</code></p>
<p><code>int pipe(int filedis[2]);</code> </p>
<p>成功返回0，否则返回-1</p>
<p>filedis[0]用于读管道， filedis[1]用于写管道。</p>
<h4 id="管道关闭"><a href="#管道关闭" class="headerlink" title="管道关闭"></a>管道关闭</h4><p>将<code>close()</code>两个文件逐个关闭即可</p>
<p>无名管道的特点：</p>
<ol>
<li><p>只能用于亲缘关系的进程通信（如父子进程</p>
</li>
<li><p>是半双工的通信模式，具有固定的读端和写端</p>
</li>
<li><p>管道可以看作是一种特殊文件，对于它的读写可以用普通的read和write函数，但它不是普通的文件，只存在于内核空间里</p>
</li>
</ol>
<h3 id="无名管道的使用"><a href="#无名管道的使用" class="headerlink" title="无名管道的使用"></a>无名管道的使用</h3><p>先创建一个管道，再通过fork函数创建一个子进程，子进程会继承父进程的管道，子进程</p>
<p>写入，父进程读。</p>
<h3 id="管道读写"><a href="#管道读写" class="headerlink" title="管道读写"></a>管道读写</h3><ol>
<li>只有在管道的读端存在时，向管道写入数据才有意义，否则写管道进程将收到内核传来的sigpipe信号</li>
<li>父子进程在运行时，它们的先后顺序不能保证，可以用sleep()函数解决</li>
<li>当使用半双工管道时，任何关联的进程都必须继承一个相关的祖先进程，因为管道存在于系统内核中，任何不在创建管道的进程的祖先进程之中的进程都无法寻址它，而在命名管道</li>
</ol>
<h3 id="命名管道FIFO"><a href="#命名管道FIFO" class="headerlink" title="命名管道FIFO"></a>命名管道FIFO</h3><p>命名管道可以使不相关的进程也交换数据。</p>
<p><code>#include &lt;sys/types.h&gt;</code></p>
<p><code>#include&lt;sys/state.h&gt;</code></p>
<p><code>int mkfifo(const char*pathname, mode_t mode)</code></p>
<p>pathname ： fifo文件名</p>
<p>mode：模式 </p>
<p><code>O_NONBLOCK</code></p>
<p>对于读进程，若该管道时非阻塞打开，如果fifo内无数据，读函数立即返回0</p>
<p>对读进程，若非阻塞打开，则读操作进行部分写入或者调用失败。</p>
<p>成功返回0，错误返回1</p>
<h3 id="管道删除"><a href="#管道删除" class="headerlink" title="管道删除"></a>管道删除</h3><p><code>EACES</code></p>
<p><code>EEXIST</code></p>
<p><code>ENAMETOOLONG</code></p>
<p><code>ENOENT</code></p>
<h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p> <img src="https://pic3.zhimg.com/80/v2-c2aca533a7dbdee6c69f5116578d2436_1440w.jpg" alt="img"> </p>
<blockquote>
<p>消息队列本质是位于内和空间的链表，链表的每一个节点都是一条消息，每一条消息都有自己的消息类型，消息类型用整数来表示，而且必须大于0，每种类型的消息都被对应的链表所维护：</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/16823531-baf6c22c59b827fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/685" alt="img"></p>
<p>其中1表示类型为1的消息，2，3，4，类似</p>
<p>消息类型为0的链表记录了所有消息加入队列的顺序，其中红色箭头表示消息加入的顺序</p>
<h3 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建和获取ipc内核对象</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> flags)</span> </span>;</span><br><span class="line"><span class="comment">// 将消息发送到消息队列</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgsnd</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">const</span> <span class="keyword">void</span> *msgp, <span class="keyword">size_t</span> msgsz, <span class="keyword">int</span> msgflg)</span></span>;</span><br><span class="line"><span class="comment">//从消息队列获取消息</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">msgrcv</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">void</span> *msgp, <span class="keyword">size_t</span> msgsz,<span class="keyword">long</span> msgtyp, <span class="keyword">int</span> msgflg)</span> </span>;</span><br><span class="line"><span class="comment">// 查看，设置，删除ipc对象</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgctl</span><span class="params">(<span class="keyword">int</span> msqid,<span class="keyword">int</span> cmd,struct msqid_ds *buf)</span> </span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="ftok"><a href="#ftok" class="headerlink" title="ftok"></a>ftok</h3><blockquote>
<p>  关于ftok函数，先不去了解它的作用来先说说为什么要用它，共享内存，消息队列，信号量它们三个都是找一个中间介质，来进行通信的，这种介质多的是。就是怎么区分出来，就像唯一一个身份证来区分人一样。你随便来一个就行，就是因为这。只要唯一就行，就想起来了文件的设备编号和节点，它是唯一的，但是直接用它来作识别好像不太好，不过可以用它来产生一个号。ftok()就出场了</p>
</blockquote>
<p><code>key_t ftok(char *fname, int id)</code></p>
<p>fname 就是你指定的文件名，该文件必须是存在而且可访问</p>
<p>id 是子序号， 只有8bit可以被使用 0-255</p>
<p>   1、ftok根据路径名，提取文件信息，再根据这些文件信息及project ID合成key，该路径可以随便设置。</p>
<p>2、该路径是必须存在的，ftok只是根据文件inode在系统内的唯一性来取一个数值，和文件的权限无关。</p>
<p>3、proj_id是可以根据自己的约定，随意设置。这个数字,有的称之为project ID; 在UNIX系统上,它的取值是1到255;</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u013485792/article/details/50764224">https://blog.csdn.net/u013485792/article/details/50764224</a></p>
<h3 id="msgget"><a href="#msgget" class="headerlink" title="msgget"></a>msgget</h3><p>创建消息队列</p>
<p>int msgget(key_t , int msgflg) ;</p>
<p>key：某个消息队列的名字</p>
<p>msgflg：由9个权限标志构成，用法和创建文件的一样</p>
<p><code>IPC_CREAT</code>  如果消息队列不存在，则创建，否则进行打开操作</p>
<p><code>IPC_EXCL</code>  如果消息队列不存在，则创建，否则产生错误并返回</p>
<p>成功则返回一个非负整数为该消息队列的标识码</p>
<p>失败返回-1</p>
<h3 id="msgsnd-函数"><a href="#msgsnd-函数" class="headerlink" title="msgsnd 函数"></a>msgsnd 函数</h3><p>msgsnd 函数用于将数据发送到消息队列。如果该函数被信号打断，会设置 errno 为 EINTR。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgsnd</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">const</span> <span class="keyword">void</span> *msgp, <span class="keyword">size_t</span> msgsz, <span class="keyword">int</span> msgflg)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>msqid：由msgget函数返回的消息队列标识码</p>
<p>msg_ptr：指针，准备发送的消息的地址</p>
<p>msgsz：消息正文部分的大小（不包含消息类型）</p>
<p>msgflg：可选项， </p>
<p>为0 ：如果消息队列空间不够，msgsnd会阻塞</p>
<p>IPC_NOWAIT ：直接返回，如果空间不够，会设置errno为EAGIN</p>
<p>返回： 0表示成功，-1失败，并设置errno</p>
<h3 id="msgrcv函数"><a href="#msgrcv函数" class="headerlink" title="msgrcv函数"></a>msgrcv函数</h3><p>msgrcv 函数从消息队列取出消息后，并将其从消息队列里删除。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">msgrcv</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">void</span> *msgp, <span class="keyword">size_t</span> msgsz, <span class="keyword">long</span> msgtyp, <span class="keyword">int</span> msgflg)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>参数 msqid：ipc 内核对象 id<br> 参数 msgp：用来接收消息数据地址<br> 参数 msgsz：消息正文部分的大小（不包含消息类型）<br> 参数 msgtyp：指定获取哪种类型的消息</p>
<p>msgtyp = 0：获取消息队列中的第一条消息<br> msgtyp &gt; 0：获取类型为 msgtyp 的第一条消息，除非指定了 msgflg 为MSG_EXCEPT，这表示获取除了 msgtyp 类型以外的第一条消息。<br> msgtyp &lt; 0：获取类型 ≤|msgtyp|≤|msgtyp| 的第一条消息。<br> 参数 msgflg：可选项。<br> 如果为 0 表示没有消息就阻塞。<br> IPC_NOWAIT：如果指定类型的消息不存在就立即返回，同时设置 errno 为 ENOMSG<br> MSG_EXCEPT：仅用于 msgtyp &gt; 0 的情况。表示获取类型不为 msgtyp 的消息<br> MSG_NOERROR：如果消息数据正文内容大于 msgsz，就将消息数据截断为 msgsz</p>
<h3 id="消息数据格式"><a href="#消息数据格式" class="headerlink" title="消息数据格式"></a>消息数据格式</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Msg</span>&#123;</span></span><br><span class="line">    <span class="keyword">long</span> type; <span class="comment">// 消息类型。这个是必须的，而且值必须 &gt; 0，这个值被系统使用</span></span><br><span class="line">    <span class="comment">// 消息正文，多少字节随你而定</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="msgctl函数"><a href="#msgctl函数" class="headerlink" title="msgctl函数"></a>msgctl函数</h3><p>获取和设置消息队列的属性</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">msgctl</span>(<span class="params"><span class="built_in">int</span> msqid, <span class="built_in">int</span> cmd, <span class="keyword">struct</span> msqid_ds *buf</span>)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>msqid：消息队列标识符<br> cmd：控制指令<br> IPC_STAT:获得msgid的消息队列头数据到buf中<br> IPC_SET：设置消息队列的属性，要设置的属性需先存储在buf中，可设置的属性包括：msg_perm.uid、msg_perm.gid、msg_perm.mode以及msg_qbytes<br> buf：消息队列管理结构体。</p>
<p>返回值：<br> 成功：0<br> 出错：-1，错误原因存于error中<br> EACCESS：参数cmd为IPC_STAT，确无权限读取该消息队列<br> EFAULT：参数buf指向无效的内存地址<br> EIDRM：标识符为msqid的消息队列已被删除<br> EINVAL：无效的参数cmd或msqid<br> EPERM：参数cmd为IPC_SET或IPC_RMID，却无足够的权限执行</p>
<h3 id="查看消息队列"><a href="#查看消息队列" class="headerlink" title="查看消息队列"></a>查看消息队列</h3><p><code>ipcs -q</code>  命令查看已经创建的消息队列，包括key值信息,id消息，拥有者消息，文件权限消息</p>
<p><code>ipcrm </code> 加消息队列的key值，或者删除一个消息队列</p>
<h2 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h2><p>实现进程间通信最简单也是最直接的方法就是共享内存——为参与通信的多个进程在内存中开辟一个共享区。由于进程可以直接对共享内存进行读写操作，因此这种通信方式效率特别高，但其弱点是，它没有互斥机制，需要信号量之类的手段来配合。</p>
<p> 共享内存的实现：</p>
<ol>
<li>在内存中划出一块区域作为共享区</li>
<li>把这个区域映射到参与通信的各个进程空间</li>
</ol>
<p>划出一个区域的方法：打开一个文件，通过系统调用mmap() 把文件所占用的内存空间映射到参与通信的各个进程地址空间中，则这些进程都可以看到这个共享区域</p>
<p>&lt;sys/shm.h&gt; </p>
<p><code>void *mmap(void *start, size_t len, int port, int flags, int fd, off_t offset)  </code></p>
<p>fd 用来指定被映射的文件</p>
<p>offset指定映射的起始位置偏移量 （通常为0</p>
<p>len 指定文件被映射部分的长度</p>
<blockquote>
<p>mmap是一种内存映射文件的方法，即将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系。实现这样的映射关系后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页面到对应的文件磁盘上，即完成了对文件的操作而不必再调用read,write等系统调用函数。相反，内核空间对这段区域的修改也直接反映用户空间，从而可以实现不同进程间的文件共享。、</p>
</blockquote>
<p> <img src="https://img-blog.csdn.net/20180807210110732?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDEwNzMw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"> </p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38410730/article/details/81488145">https://blog.csdn.net/qq_38410730/article/details/81488145</a></p>
<h3 id="shmget"><a href="#shmget" class="headerlink" title="shmget"></a>shmget</h3><p>创建共享内存</p>
<p><code>int shmget(key_t key, size_t size, int shmflg) ;</code> </p>
<p>key为共享内存段命名</p>
<p>size以字节为单位指定需要共存的内存容量</p>
<p>shmflg是权限标志，作用和open中的mode参数一样</p>
<p>调用成功后返回一个与key相关的共享内存标识符， 失败返回-1</p>
<blockquote>
<p>不相关的进程可 以通过该函数的返回值访问同一共享内存，它代表程序可能要使用的某个资源，程序对所有共享内存的访问都是间接的，程序先通过调用shmget函数并提供一 个键，再由系统生成一个相应的共享内存标识符（shmget函数的返回值），只有shmget函数才直接使用信号量键，所有其他的信号量函数使用由 semget函数返回的信号量标识符。</p>
</blockquote>
<h3 id="shmat函数"><a href="#shmat函数" class="headerlink" title="shmat函数"></a>shmat函数</h3><p>第一次创建完共享内存时，他还不能被任何进程访问，shmat函数的作用就是启动对该共享内存的访问，并把共享内存链接到当前进程的地址空间</p>
<p><code>void *shmat(int shm_id, const void *shm_addr, int shmflg);</code></p>
<p>shm_id 是由shmget函数返回的共享内存标识符</p>
<p>shm_addr指定共享内存链接到当前进程中的地址位置，通常为空，表示让系统来选择共享内存的地址</p>
<p>shm_flg 是一组标志位，通常为0</p>
<p>调用成功时返回一个指向共享内存第一个字节的指针，如果调用失败返回-1 </p>
<h3 id="shmdt-解除映射"><a href="#shmdt-解除映射" class="headerlink" title="shmdt 解除映射"></a>shmdt 解除映射</h3><p> 该函数用于将共享内存从当前进程中分离。注意，将共享内存分离并不是删除它，只是使该共享内存对当前进程不再可用。</p>
<p><code>int shmdt(const void *shmaddr)</code><br>参数shmaddr是shmat函数返回的地址指针，成功返回0，失败返回-1 </p>
<h3 id="信号量同步"><a href="#信号量同步" class="headerlink" title="信号量同步"></a>信号量同步</h3><ol>
<li>利用posix有名信号灯实现共享内存的同步</li>
<li>利用posix无名信号灯实现共享内存的同步</li>
<li>利用System V </li>
<li>利用信号</li>
</ol>
<h3 id="shm-open"><a href="#shm-open" class="headerlink" title="shm_open"></a>shm_open</h3><p><code>int shm_open(const char*name,int oflag, mode_t mode);</code></p>
<p>用于创建或者打开共享内存文件</p>
<p>name：要打开或创建的文件名</p>
<p>返回fd&gt;0 ,失败返回-数</p>
<p>oflag： 打开文件的操作属性：O_CREAT,O_RDWR,O_EXCL</p>
<h3 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h3><p>void *mmap(void *addr, size_t length, int prot, int flags,int fd, off_t offset);</p>
<p>功能说明: <strong>将打开的文件映射到内存，一般是将shm_open打开的文件映射到内存</strong>，当然也可以将硬盘上的用open打开的文件映射到内存。这个函数只是将文件映射到内存中，使得我们用操作内存指针的方式来操作文件。</p>
<p>参数说明：</p>
<p>addr：要将文件映射到的内存地址，一般应该传递NULL来由Linux内核指定。</p>
<p>length：要映射的文件数据长度。</p>
<p>prot：映射的内存区域的操作权限（保护属性），包括PROT_READ、PROT_WRITE、PROT_READ|PROT_WRITE</p>
<p>flags：标志位参数，包括：MAP_SHARED、MAP_PRIVATE与MAP_ANONYMOUS。<br>            MAP_SHARED:  建立共享，用于进程间通信，如果没有这个标志，则别的进程即使能打开文件，也看不到数据。<br>            MAP_PRIVATE: 只有进程自己用的内存区域<br>            MAP_ANONYMOUS:匿名映射区</p>
<p>fd：   用来建立映射区的文件描述符，用 shm_open打开或者open打开的文件。</p>
<p>offset：映射文件的偏移，应该按4096字节对齐。</p>
<p>返回值:成功返回映射的内存地址指针，可以这个地址进行内存的读写操作；如果 失败则返回NULL。</p>
<h3 id="munmap"><a href="#munmap" class="headerlink" title="munmap"></a>munmap</h3><p>int munmap(void *addr, size_t length);</p>
<p>功能说明: 取消内存映射，addr是由mmap成功返回的地址，length是要取消的内存长度，munmap 只是将映射的内存从进程的地址空间撤销，如果不调用这个函数，则在进程终止前，该片区域将得不到释放。</p>
<h3 id="shm-unlink"><a href="#shm-unlink" class="headerlink" title="shm_unlink"></a>shm_unlink</h3><p>int shm_unlink(const char *name);</p>
<p>功能说明：删除/dev/shm目录的文件，shm_unlink 删除的文件是由shm_open函数创建于/dev/shm目录的。可以用系统函数unlink来达到同样的效果，用/dev/shm + name 组成完整的路径即可，但一般不要这么做，因为系统的tmpfs的位置也许不是/dev/shm。用shm_open　创建的文件，如果不调用此函数删除，会一直存在于/dev/shm目录里，直到操作系统重启或者调用linux命令rm来删除为止。</p>
<h3 id="ftruncate"><a href="#ftruncate" class="headerlink" title="ftruncate"></a>ftruncate</h3><p>int ftruncate(int fd, off_t length)</p>
<p><strong>功能说明</strong>：重置文件大小。任何open打开的文件都可以用这个函数，不限于shm_open打开的文件。</p>
<p>好了，以下是共享内存操作的实践代码：</p>
<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><p>编译连接参数 -lpthread </p>
<p> <img src="https://images0.cnblogs.com/blog2015/570460/201507/041632598968698.png" alt="img"> </p>
<p>每一个线程都有一个线程ID，不同的是，进程id在系统中是唯一的，而线程是依附于进程的， 其线程id只有在所属的进程中才有意义，线程id用pthread_t 表示</p>
<h3 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h3><p>创建线程的函数</p>
<p><code>#include &lt;pthread.h&gt;</code></p>
<p><code>pthread_create(pthread_t *thread,const pthread_attr_t   *attr , void *(*start_routine)(void*), void *arg)</code></p>
<p>attr：要创建线程的属性</p>
<p>start_routine 为线程开始执行的函数</p>
<blockquote>
<p><strong>arg为start_routine 的参数 （不能为局部变量，否则使用的时候可能已经被修改或者不存在了！！！）</strong> </p>
<p>如果有多个参数，只能打包成结构体 </p>
<ul>
<li><p>新线程的运行时机，一个线程被创建之后有可能不会被马上执行，甚至，在创建它的线程结束后还没被执行；也有可能新线程在当前线程从pthread_create前就已经在运行，甚至，在pthread_create前从当前线程返回前新线程就已经执行完毕。</p>
</li>
<li><p>主线程，这是一个进程的初始线程，其入口函数为main函数。</p>
</li>
</ul>
<p>主线程结束后所有线程都结束</p>
</blockquote>
<p><code>pthread_t pthread_self(void);</code></p>
<p><code>int pthread_equal(pthread_t t1,pthread_t t2);</code></p>
<h3 id="线程终止"><a href="#线程终止" class="headerlink" title="线程终止"></a>线程终止</h3><p>被动终止和主动终止</p>
<p>被动终止： </p>
<ol>
<li>线程所在进程终止，任意线程执行<code>exit</code>、<code>_Exit</code>或者<code>_exit</code>函数，都会导致进程终止，从而导致依附于该进程的所有线程终止。</li>
<li>其他线程调用<code>pthread_cancel</code>请求取消该线程。</li>
</ol>
<p><code>void pthread_exit(void *retval); </code></p>
<p><code>int pthread_cancel(pthread_ p)</code></p>
<h3 id="线程连接"><a href="#线程连接" class="headerlink" title="线程连接"></a>线程连接</h3><p>一个线程的终止对于另外一个线程而言是一种异步的事件，有时我们想等待某个ID的线程终止了再去执行某些操作，<code>pthread_join</code>函数为我们提供了这种功能，该功能称为线程的连接：</p>
<p><code>int pthread_join(thread_t thread,void)</code></p>
<blockquote>
<p>thread(输入参数)，指定我们希望等待的线程<br>retval(输出参数)，我们等待的线程终止时的返回值，就是在线程入口函数中return的值或者调用pthread_exit函数的参数</p>
</blockquote>
<p>成功返回0，错误返回正数错误码</p>
<p>连接线程其实还有另外一层意义，一个线程终止后，如果没有人对它进行连接，那么该终止线程占用的资源，系统将无法回收，而该终止线程也会成为僵尸线程。因此，当我们去连接某个线程时，其实也是在告诉系统该终止线程的资源可以回收了。</p>
<h3 id="线程的分离"><a href="#线程的分离" class="headerlink" title="线程的分离"></a>线程的分离</h3><p>希望某一个线程终止了，系统能自动回收该终止线程占用的资源 </p>
<p><code>int pthread_detach(pthread_t thread);</code></p>
<blockquote>
<p>默认情况下，一个线程终止了，是需要在被连接后系统才能回收其占有的资源的。如果我们调用pthread_detach函数去分离某个线程，那么该线程终止后系统将自动回收其资源。</p>
</blockquote>
<h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>#include &lt;semaphore.h&gt;</p>
<p>互斥锁指针变量的定义方法：<code>pthread_mutex_t *mutex</code></p>
<p><code>int pthread_mutex_init(pthread_mutex_t *, const pthread_mutex_attr_t *mutexattr);</code>  初始化函数</p>
<p>参数：定义好的互斥指针</p>
<p>参数 mutexattr ， 互斥量属性，一般为NULL（缺省属性）</p>
<blockquote>
<p>不同属性在试图对一个已经被锁定的互斥锁加锁时表现不同，有四个值可以选择：</p>
<ol>
<li>PTHREAD_MUTEX_TIMED_NP 缺省时的值， 就是普通锁， 当一个线程加锁以后，其余请求锁的线程将形成一个等待队列，并在解锁后按优先级获得锁。这种锁策略保证了资源分配的公平性</li>
<li>PTHREAD_MUTEX_RECURSIVE_NP 嵌套锁，允许同一个进程对同一个锁成功获取多次，并通过unlock解锁多次         如果是不同线程请求，则在加锁线程解锁时重新竞争。   </li>
<li>PTHREAG_MUTEX_ERRORCHECK_NP 检错锁，如果同一个进程请求同意一个锁，则返回EDEADLK，否则和普通锁相同。保证当不允许多次加锁时不会出现最简单的死锁情况</li>
<li>PTHREAD_MUTEX_ADAPTIVE_NP 适应锁，动作最简单的锁类型，仅等待解锁后重新竞争。</li>
</ol>
</blockquote>
<p>成功后返回0，其他的都是错误</p>
<p>加🔓操作函数：</p>
<p><code> int pthread_mutex_lock(pthread_mutex_t *mutex);</code> </p>
<p><code>int pthread_mutex_unlock(phtread_mutext_t *mutex);</code></p>
<h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><p><code>#include &lt;pthread.h</code></p>
<p><code>pthread_cond_t </code></p>
<p>线程的东西，就是等待某一条件的发生，和信号一样，可以使我们睡眠等待某种条件的出现。</p>
<blockquote>
<p>用条件变量是利用线程间共享的全局变量，进行同步的一种机制，主要包括两个动作：一个线程等待”条件变量的条件成立”而挂起；另一个线程使”条件成立”（给出条件成立信号）。为了防止竞争，条件变量的使用总是和一个互斥锁结合在一起。</p>
</blockquote>
<h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><p>和互斥锁一样，都有静态和动态两种创建方式，</p>
<p>静态使用 <code>PTHREAD_COND_INITALIZER</code> </p>
<p>如下： </p>
<p><code>pthread_cond_t cond = PTHREAD_COND_INITALIZER</code> </p>
<p>动态调用 pthread_cond_init() 函数</p>
<p><code>int pthread_cond_init( pthread_cond_t *cond,pthread_condattr_t * cond_attr)</code>   </p>
<p>属性的默认值是 PTHREAD_ PROCESS_PRIVATE，即此条件变量被同一进程内的各个线程使用。</p>
<h4 id="注销"><a href="#注销" class="headerlink" title="注销"></a>注销</h4><p>注销一个条件变量需要调用pthread_cond_destroy()，只有在没有线程在该条件变量上等待的时候，才能注销这个条件变量，否则返回EBUSY。API定义如下：</p>
<p>int pthread_cond_destroy(pthread_cond_t *cond)</p>
<h4 id="线程阻塞"><a href="#线程阻塞" class="headerlink" title="线程阻塞"></a>线程阻塞</h4><p><code>int pthread_cond_wait </code></p>
<blockquote>
<p>　extern int pthread_cond_wait    (pthread_cond_t *  cond,pthread_mutex_t *__mutex); </p>
<p>　　调用这个函数时,线程解开mutex指向的锁并被条件变量cond阻塞。线程可以被函数pthread_cond_signal和函数 pthread_cond_broadcast唤醒。线程被唤醒后，它将重新检查判断条件是否满足，如果还不满足，一般说来线程应该仍阻塞在这里，被等待被下一次唤醒。这个过程一般用while语句实现。</p>
</blockquote>
<h4 id="休眠"><a href="#休眠" class="headerlink" title="休眠"></a>休眠</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_timedwait</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond_interface,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="keyword">pthread_mutex_t</span> * mutex,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="keyword">const</span> timespec *abstime)</span></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>abstime 是一个绝对时间， 原型：</p>
<p>struct timespce {</p>
<p>​    time_t tv_sec;  // 秒</p>
<p>​    long tv_nsec ;  // 纳秒</p>
<p>}</p>
<p><strong>pthread_cond_timedwait</strong>允许线程就阻塞时间设置一个限制值。指定了这个函数必须返回时的系统时间，即使当相对条件下还没有收到信号。</p>
</blockquote>
<h1 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h1><p>信号是软件中断，它可以作为进程通信的一种机制</p>
<h3 id="信号的名字和编号："><a href="#信号的名字和编号：" class="headerlink" title="信号的名字和编号："></a>信号的名字和编号：</h3><ul>
<li>每个信号都有一个名字和编号，这些名字都以“SIG”开头，例如“SIGIO ”、“SIGCHLD”等等。</li>
<li>信号定义在<code>signal.h</code>头文件中，信号名都定义为正整数。</li>
<li>具体的信号名称可以使用<code>kill -l</code>来查看信号的名字以及序号，信号是从1开始编号的，不存在0号信号。kill对于信号0又特殊的应用。</li>
</ul>
<h3 id="信号的处理："><a href="#信号的处理：" class="headerlink" title="信号的处理："></a>信号的处理：</h3><p> 信号的处理有三种方法，分别是：忽略、捕捉和默认动作</p>
<ul>
<li>忽略信号，大多数信号可以使用这个方式来处理，但是有两种信号不能被忽略（分别是 <code>SIGKILL</code>和<code>SIGSTOP</code>）。因为他们向内核和超级用户提供了进程终止和停止的可靠方法，如果忽略了，那么这个进程就变成了没人能管理的的进程，显然是内核设计者不希望看到的场景</li>
<li>捕捉信号，需要告诉内核，用户希望如何处理某一种信号，说白了就是写一个信号处理函数，然后将这个函数告诉内核。当该信号产生时，由内核来调用用户自定义的函数，以此来实现某种信号的处理。</li>
<li>系统默认动作，对于每个信号来说，系统都对应由默认的处理动作，当发生了该信号，系统会自动执行。不过，对系统来说，大部分的处理方式都比较粗暴，就是直接杀死该进程。<br>具体的信号默认动作可以使用<code>man 7 signal</code>来查看系统的具体定义。</li>
</ul>
<p>不可靠信号：Linux信号机制基本上是从</p>
<p>可靠信号：位于SIGRTMINhe SIGRTMAX之间的信号</p>
<h3 id="信号注册函数"><a href="#信号注册函数" class="headerlink" title="信号注册函数"></a>信号注册函数</h3><p>信号的使用：</p>
<ol>
<li>安装（注册）信号</li>
<li>实现三参数的信号函数</li>
<li>发送信号</li>
</ol>
<blockquote>
<p>处理中断都需要处理什么问题。 可以发送的信号类型是多种多样的，每种信号的处理可能也不同，所以我们需要知道发生了什么信号。</p>
</blockquote>
<p><code>#include &lt;signal.h&gt;</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">sighandler_t</span>)</span><span class="params">(<span class="keyword">int</span>)</span> </span>;</span><br><span class="line"><span class="function"><span class="keyword">sighandler_t</span> <span class="title">signal</span><span class="params">(<span class="keyword">int</span> signum, <span class="keyword">sighandler_t</span> 	handler)</span></span>; </span><br><span class="line">signum 是信号的编号</span><br><span class="line">handler是中断函数的指针。</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="semget"><a href="#semget" class="headerlink" title="semget"></a>semget</h3><p><code>int semget(key_t key, int sems, int sem_flags);</code></p>
<p> key：信号集的名字</p>
<p> nsems：信号集中信号量的个数</p>
<p>semflg：九个权限标志构成，用法与创建文件的mode模式标志一致</p>
<p>返回值：成功返回一个非负整数即该信号集的标识码；失败返回-1</p>
<h3 id="semop"><a href="#semop" class="headerlink" title="semop"></a>semop</h3><p><code>int semop(int sem_id , struct sembuf*sem_opa, size_t num_sem_ops) </code></p>
<p>作用改变信号量的值 </p>
<p>semid 是semget返回的信号量标识符</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span>&#123;</span></span><br><span class="line">    <span class="keyword">short</span> sem_num; <span class="comment">// 除非使用一组信号量，否则它为0</span></span><br><span class="line">    <span class="keyword">short</span> sem_op;  <span class="comment">// 信号量在一次操作中需要改变的数据，通常是两个数，一个是-1，即P（等待）操作，</span></span><br><span class="line">                   <span class="comment">// 一个是+1，即V（发送信号）操作。</span></span><br><span class="line">    <span class="keyword">short</span> sem_flg; <span class="comment">// IPC_NOWAIT| SEM_UNDO</span></span><br><span class="line">    <span class="comment">//通常为SEM_UNDO,使操作系统跟踪信号，</span></span><br><span class="line">                   <span class="comment">// 并在进程没有释放该信号量而终止时，操作系统释放信号量</span></span><br><span class="line">                   &#125;;</span><br></pre></td></tr></table></figure>

<p>num_sem_ops 参数指出由sops指向的sembuff结构数组中元素的数目，该数组中每个元素给目标信号集内某个特定的信号量操作</p>
<blockquote>
<p><strong>sem_flag的取值有三种：</strong></p>
<p>　 1).0代表阻塞调用</p>
<p>　2).IPC_NOWAIT代表非阻塞调用</p>
<p>　3).如果设置了SEM_UNDO标志，那么在进程结束时，相应的操作将被取消，这是比较重要的一个标志位。如果设置了该标志位，那么在进程没有释放共享资源就退出时，内核将代为释放。如果为一个信号量设置了该标志，内核都要分配一个SEM_UNDO结构来记录它，为的是确保以后资源能够安全释放。事实上，如果进程退出了，那么它所占用的资源就释放了，但信号量值却没有改变，此时，信号量值反映的已经不是资源占有的实际情况，在这种情况下，问题的解决就靠内核来完成。这有点像僵尸进程，进程虽然退出了，资源也都释放了，但内核进程表中仍然有它的记录，此时就需要父进程调用waitpid来解决问题了。</p>
</blockquote>
<h3 id="semctl"><a href="#semctl" class="headerlink" title="semctl"></a>semctl</h3><p>#include &lt;sys/sem.h&gt;</p>
<p>int semctl(int semid, int semnum, int cmd, … );</p>
<p>semctl() 在 <em>semid</em> 标识的信号量集上，或者该集合的第<em>semnum</em> 个信号量上执行 <em>cmd</em> 指定的控制命令。(信号量集合索引起始于零。)</p>
<p>根据 <em>cmd</em> 不同，这个函数有三个或四个参数。当有四个参数时，第四个参数的类型是 <em>unionsemun</em>。<em>调用程序</em> 必须按照下面方式定义这个联合体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">semun</span> &#123;</span> </span><br><span class="line"></span><br><span class="line">         <span class="keyword">int</span>              val;               <span class="comment">// SETVAL使用的值   </span></span><br><span class="line"></span><br><span class="line">         <span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> *<span class="title">buf</span>;</span>  <span class="comment">// IPC_STAT、IPC_SET 使用缓存区</span></span><br><span class="line"></span><br><span class="line">         <span class="keyword">unsigned</span> <span class="keyword">short</span>  *<span class="built_in">array</span>;  <span class="comment">// GETALL,、SETALL 使用的数组 </span></span><br><span class="line"></span><br><span class="line">         <span class="class"><span class="keyword">struct</span> <span class="title">seminfo</span>  *__<span class="title">buf</span>;</span>  <span class="comment">// IPC_INFO(Linux特有) 使用缓存区 </span></span><br><span class="line"></span><br><span class="line">&#125;; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果有第四个参数：cmd通常是下面两个值中的其中一个</p>
<p><strong>SETVAL</strong>：用来把信号量初始化为一个已知的值。p 这个值通过union semun中的<strong>val成员设置</strong>，其作用是在信号量第一次使用前对它进行设置。</p>
<p><strong>IPC_RMID</strong>：用于删除一个已经无需继续使用的信号量标识符。</p>
<h3 id="sem-open"><a href="#sem-open" class="headerlink" title="sem_open"></a>sem_open</h3><p>创建并初始化有名信号灯</p>
<h3 id="kill和raise"><a href="#kill和raise" class="headerlink" title="kill和raise"></a>kill和raise</h3><p>kill()可以终止进程，也可以向进程发送其他信号</p>
<p>rasie() 函数运行向进程自身发送信号</p>
<p>kill的pid参数四种不同情况</p>
<p>pid&gt;0 将信号发送给进程为pid的进程</p>
<p>pid=0 将信号发送给其进程组id，等于发送进程的进程组id，而且发送进程有许可权向其发送信号的所有进程。</p>
<h3 id="发送信号"><a href="#发送信号" class="headerlink" title="发送信号"></a>发送信号</h3><p><code>int sigqueue(pid_t pid,int sig, const union sigval value)</code></p>
<p>pid：接收信号的进程</p>
<p>sig：要发送的信号</p>
<p>value：是一个整型和指针类型 </p>
<h1 id="linux文件系统"><a href="#linux文件系统" class="headerlink" title="linux文件系统"></a>linux文件系统</h1><h3 id="初探"><a href="#初探" class="headerlink" title="初探"></a>初探</h3><blockquote>
<p> 操作系统的文件数据除了实际内容之外，通常含有非常多的属性，例如<code>Linux</code>操作系统的文件权限与文件属性。文件系统通常会将这两部分内容分别存放在<code>inode</code>和<code>block</code>中。 </p>
</blockquote>
<p> <img src="https://images0.cnblogs.com/blog/413416/201402/250221581092754.png" alt="img"> </p>
<p> <img src="http://c.biancheng.net/cpp/uploads/allimg/140901/1-140Z11I213549.png" alt="img"> </p>
<p> <img src="https://img-blog.csdnimg.cn/20200504135556323.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ptaWxr,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"> </p>
<h3 id="inode"><a href="#inode" class="headerlink" title="inode"></a>inode</h3><p>文件是存储在硬盘上的，硬盘的最小存储单位叫做扇区，每一个扇区存储512字节，操作系统读取硬盘时，是一次性连续地读取多个扇区，即一次性读取一个快 block，block是文件存取的最小单位， 块的大小一般为4KB，即8个sector组成一个block </p>
<p>文件数据存储在块中，必须还需要一个数据结构存储文件的元信息，比如文件的创建者，创建日期，大小等，这个区域叫做inode，中文叫作索引节点，又叫做<code>i节点</code>，一个文件必须占用一个<code>inode</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">inode</span><br><span class="line">   用于存储文件的各属性，包括：</span><br><span class="line">    - 所有者信息：文件的owner，group；</span><br><span class="line">    - 权限信息：read、write和excite；</span><br><span class="line">    -时间信息：建立或改变时间（ctime）、最后读取时间（atime）、最后修改时间（mtime）；</span><br><span class="line">    - 标志信息：一些flags；</span><br><span class="line">    - 内容信息：type，size，以及相应的block的位置信息。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>   <strong>注意：不记录文件名或目录名，文件名或目录名记录在文件所在目录对应的block里。</strong></p>
<h3 id="FCB"><a href="#FCB" class="headerlink" title="FCB"></a>FCB</h3><blockquote>
<p>文件控制块（FCB）是操作系统为每个文件建立的<strong>唯一</strong>数据结构，其中包含了全部<strong>文件属性</strong>，为了方便操作系统对文件的管理、控制和存取</p>
<p>一个文件由两部分组成：FCB和文件体（文件信息）</p>
</blockquote>
<p>为了加快文件查找速度，通常把FCB汇聚和组织形成一个文件目录，文件目录包含很多目录项</p>
<ul>
<li>Linux将FCB中的<strong>文件名</strong>和其他管理信息分开，其他信息单独组成一个数据结构，成为索引节点<strong>inode</strong>，此索引结点的位置由inode号标识。 </li>
</ul>
<h3 id="blcok"><a href="#blcok" class="headerlink" title="blcok"></a>blcok</h3><p>文件属性由inode存储，block由文件内容存储</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &quot;fileSystem.h&quot;</span><br><span class="line">#include &quot;fcb.h&quot;</span><br><span class="line">#define    LS     &quot;ls&quot;</span><br><span class="line">#define    TOUCH   &quot;touch&quot;</span><br><span class="line">#define    CD     &quot;cd&quot;</span><br><span class="line">#define    RM     &quot;RM&quot;</span><br><span class="line">#define    MV     &quot;mv&quot;</span><br><span class="line">#define    RMDIR     &quot;rmdir&quot;</span><br><span class="line">#define    MKDIR     &quot;mkdir&quot;</span><br><span class="line">#define    READ     &quot;read&quot;</span><br><span class="line">#define    WRITE   &quot;write&quot;</span><br><span class="line">#define    HLEP     &quot;help&quot;</span><br><span class="line">#define    CAT      &quot;cat&quot; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int analyse(char *par_buf[], int len);</span><br><span class="line">void showTip() ;</span><br><span class="line">//字符串解析函数</span><br><span class="line">int parse(char *par_buf[], char str[]);</span><br><span class="line">   </span><br><span class="line">int main()&#123;</span><br><span class="line">    initFileSystem();</span><br><span class="line">    char *par_buf[20] = &#123;0&#125;;</span><br><span class="line">    char str[20] = &#123;&#125;;</span><br><span class="line">    printf(&quot;ello\n&quot;);</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        showTip();</span><br><span class="line">        fgets(str, 20, stdin);</span><br><span class="line">        int len = parse(par_buf, str);</span><br><span class="line">        //analyse(par_buf, len) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int analyse(char *par_buf[], int len)&#123;</span><br><span class="line">    if(len&lt;1)&#123;</span><br><span class="line">        return -1; </span><br><span class="line">    &#125;</span><br><span class="line">    char *arg = par_buf[0] ; </span><br><span class="line">    char *arg1=par_buf[1]; </span><br><span class="line">    </span><br><span class="line">    if(strcmp(arg,LS)==0)</span><br><span class="line">        ls() ;</span><br><span class="line">    else if(strcmp(arg,TOUCH) ==0 )&#123;</span><br><span class="line">        if(len&lt;3) return -1 ;</span><br><span class="line">        // 可能有bug</span><br><span class="line">        arg1 = par_buf[1];</span><br><span class="line">        int size = atoi(arg1) ;</span><br><span class="line">        if(size &lt;= 9 &amp;&amp; size&gt;=0)&#123;</span><br><span class="line">            printf(&quot;size is %d\n&quot;, size) ;</span><br><span class="line">            touch( arg1, size);</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            printf(&quot;arg1%s is worng ！\n&quot;, arg1) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    else if((strcmp(arg,RM) ==0 ))&#123;</span><br><span class="line">        rm(arg1);</span><br><span class="line">    &#125;</span><br><span class="line">    else if( (strcmp(arg,CD) ==0) ) &#123;</span><br><span class="line">        cd(arg1);</span><br><span class="line">    &#125;</span><br><span class="line">    else if((strcmp(MKDIR,arg) ==0 ))&#123;</span><br><span class="line">        mkdir(arg1);</span><br><span class="line">    &#125;</span><br><span class="line">    else if((strcmp(arg,RMDIR)==0))&#123;</span><br><span class="line">        rmdir(arg1);</span><br><span class="line">    &#125;</span><br><span class="line">    else if((strcmp(arg,MV)==0))&#123;</span><br><span class="line">        if(len&lt;3) return -1; </span><br><span class="line">         char *arg2= par_buf[2] ;</span><br><span class="line">         mv(arg1, arg2);</span><br><span class="line">    &#125;</span><br><span class="line">    else if ((strcmp(arg, WRITE) == 0))</span><br><span class="line">    &#123;</span><br><span class="line">        if (len &lt; 3)</span><br><span class="line">            return -1;</span><br><span class="line">        char *arg2 = par_buf[2];</span><br><span class="line">        write(arg1, arg2);</span><br><span class="line">    &#125;</span><br><span class="line">    else if((strcmp(arg,READ)==0))</span><br><span class="line">    &#123;</span><br><span class="line">        if(len&lt;3) return -1 ;</span><br><span class="line">        char  *arg2  = par_buf[2] ;</span><br><span class="line">        int size = atoi(arg2) ;</span><br><span class="line">        if(size &lt;0 || size&gt;9) &#123;</span><br><span class="line">            printf(&quot;the number is wrong！ %s \n&quot;, arg2) ;</span><br><span class="line">            return -1 ;</span><br><span class="line">        &#125;</span><br><span class="line">        read(arg1, size) ;</span><br><span class="line">    &#125;</span><br><span class="line">    else </span><br><span class="line">        return -1 ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void showTip()</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;&gt;&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//字符串解析函数</span><br><span class="line">int parse(char *par_buf[], char str[])</span><br><span class="line">&#123;</span><br><span class="line">    int idx = 0;</span><br><span class="line">    char *p;</span><br><span class="line">    p = strtok(str, &quot; &quot;);</span><br><span class="line">    par_buf[idx++] = p;</span><br><span class="line">    while ((p = strtok(NULL, &quot; &quot;)))</span><br><span class="line">    &#123;</span><br><span class="line">        par_buf[idx++] = p;</span><br><span class="line">    &#125;</span><br><span class="line">    return idx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br></pre></td><td class="code"><pre><span class="line">Xshell 7 (Build 0056)</span><br><span class="line">Copyright (c) 2020 NetSarang Computer, Inc. All rights reserved.</span><br><span class="line"></span><br><span class="line">Type `help&#x27; to learn how to use Xshell prompt.</span><br><span class="line">[C:\~]$ </span><br><span class="line"></span><br><span class="line">Connecting to 47.100.108.193:22...</span><br><span class="line">Could not connect to &#x27;47.100.108.193&#x27; (port 22): Connection failed.</span><br><span class="line"></span><br><span class="line">Type `help&#x27; to learn how to use Xshell prompt.</span><br><span class="line">[C:\~]$ </span><br><span class="line"></span><br><span class="line">Connecting to 47.100.108.193:22...</span><br><span class="line">Could not connect to &#x27;47.100.108.193&#x27; (port 22): Connection failed.</span><br><span class="line"></span><br><span class="line">Type `help&#x27; to learn how to use Xshell prompt.</span><br><span class="line">[C:\~]$ </span><br><span class="line"></span><br><span class="line">Connecting to 47.100.108.193:22...</span><br><span class="line">Could not connect to &#x27;47.100.108.193&#x27; (port 22): Connection failed.</span><br><span class="line"></span><br><span class="line">Type `help&#x27; to learn how to use Xshell prompt.</span><br><span class="line">[C:\~]$ </span><br><span class="line"></span><br><span class="line">Connecting to 47.100.108.193:22...</span><br><span class="line">Connection established.</span><br><span class="line">To escape to local shell, press &#x27;Ctrl+Alt+]&#x27;.</span><br><span class="line"></span><br><span class="line">WARNING! The remote SSH server rejected X11 forwarding request.</span><br><span class="line"></span><br><span class="line">Welcome to Alibaba Cloud Elastic Compute Service !</span><br><span class="line"></span><br><span class="line">Activate the web console with: systemctl enable --now cockpit.socket</span><br><span class="line"></span><br><span class="line">Last login: Sat Jul  3 09:05:51 2021 from 112.93.142.187</span><br><span class="line">[root@chenlifeng ~]# ls</span><br><span class="line">frp             optim                                               v2gen</span><br><span class="line">go              oracle-instantclient-basic-21.1.0.0.0-1.x86_64.rpm  v2ray</span><br><span class="line">kubectl         oracle-instantclient-devel-21.1.0.0.0-1.x86_64.rpm  v2ray.tar</span><br><span class="line">kubectl.sha256  oradiag_root                                        WingchiLab</span><br><span class="line">nohup.out       pkg-config-0.29.1.tar.gz                            xiaoxiao</span><br><span class="line">[root@chenlifeng ~]# cd WingchiLab</span><br><span class="line">[root@chenlifeng WingchiLab]# cd FW</span><br><span class="line">[root@chenlifeng FW]# vi fcb.h</span><br><span class="line">[root@chenlifeng FW]# vi fileSystem.h</span><br><span class="line">[root@chenlifeng FW]# gcc  -o  fcb.c main.c fileSystem.c</span><br><span class="line">In file included from fileSystem.h:3,</span><br><span class="line">                 from main.c:3:</span><br><span class="line">fcb.h:1:1: error: unknown type name ‘ifndef’</span><br><span class="line"> ifndef FCB_H</span><br><span class="line"> ^~~~~~</span><br><span class="line">fcb.h:1:13: error: expected ‘;’ before ‘typedef’</span><br><span class="line"> ifndef FCB_H</span><br><span class="line">             ^</span><br><span class="line">             ;</span><br><span class="line">fcb.h:9:1:</span><br><span class="line"> typedef struct dentry</span><br><span class="line"> ~~~~~~~      </span><br><span class="line">In file included from fileSystem.h:3,</span><br><span class="line">                 from main.c:3:</span><br><span class="line">fcb.h:55:2: error: #endif without #if</span><br><span class="line"> #endif</span><br><span class="line">  ^~~~~</span><br><span class="line">In file included from main.c:4:</span><br><span class="line">fcb.h:1:7: error: expected ‘;’ before ‘typedef’</span><br><span class="line"> ifndef FCB_H</span><br><span class="line">       ^</span><br><span class="line">       ;</span><br><span class="line">fcb.h:9:1:</span><br><span class="line"> typedef struct dentry</span><br><span class="line"> ~~~~~~~</span><br><span class="line">fcb.h:9:16: error: redefinition of ‘struct dentry’</span><br><span class="line"> typedef struct dentry</span><br><span class="line">                ^~~~~~</span><br><span class="line">In file included from fileSystem.h:3,</span><br><span class="line">                 from main.c:3:</span><br><span class="line">fcb.h:9:16: note: originally defined here</span><br><span class="line"> typedef struct dentry</span><br><span class="line">                ^~~~~~</span><br><span class="line">In file included from main.c:4:</span><br><span class="line">fcb.h:14:3: error: conflicting types for ‘dentryUnit’</span><br><span class="line"> &#125; dentryUnit;</span><br><span class="line">   ^~~~~~~~~~</span><br><span class="line">In file included from fileSystem.h:3,</span><br><span class="line">                 from main.c:3:</span><br><span class="line">fcb.h:14:3: note: previous declaration of ‘dentryUnit’ was here</span><br><span class="line"> &#125; dentryUnit;</span><br><span class="line">   ^~~~~~~~~~</span><br><span class="line">In file included from main.c:4:</span><br><span class="line">fcb.h:17:16: error: redefinition of ‘struct dentry_list’</span><br><span class="line"> typedef struct dentry_list</span><br><span class="line">                ^~~~~~~~~~~</span><br><span class="line">In file included from fileSystem.h:3,</span><br><span class="line">                 from main.c:3:</span><br><span class="line">fcb.h:17:16: note: originally defined here</span><br><span class="line"> typedef struct dentry_list</span><br><span class="line">                ^~~~~~~~~~~</span><br><span class="line">In file included from main.c:4:</span><br><span class="line">fcb.h:21:2: error: conflicting types for ‘dentryTable’</span><br><span class="line"> &#125;dentryTable;</span><br><span class="line">  ^~~~~~~~~~~</span><br><span class="line">In file included from fileSystem.h:3,</span><br><span class="line">                 from main.c:3:</span><br><span class="line">fcb.h:21:2: note: previous declaration of ‘dentryTable’ was here</span><br><span class="line"> &#125;dentryTable;</span><br><span class="line">  ^~~~~~~~~~~</span><br><span class="line">In file included from main.c:4:</span><br><span class="line">fcb.h:23:16: error: redefinition of ‘struct FCB’</span><br><span class="line"> typedef struct FCB</span><br><span class="line">                ^~~</span><br><span class="line">In file included from fileSystem.h:3,</span><br><span class="line">                 from main.c:3:</span><br><span class="line">fcb.h:23:16: note: originally defined here</span><br><span class="line"> typedef struct FCB</span><br><span class="line">                ^~~</span><br><span class="line">In file included from main.c:4:</span><br><span class="line">fcb.h:30:3: error: conflicting types for ‘fcb’</span><br><span class="line"> &#125; fcb;</span><br><span class="line">   ^~~</span><br><span class="line">In file included from fileSystem.h:3,</span><br><span class="line">                 from main.c:3:</span><br><span class="line">fcb.h:30:3: note: previous declaration of ‘fcb’ was here</span><br><span class="line"> &#125; fcb;</span><br><span class="line">   ^~~</span><br><span class="line">In file included from main.c:4:</span><br><span class="line">fcb.h:43:5: error: conflicting types for ‘doWrite’</span><br><span class="line"> int doWrite(fcb *Fcb, char content[]);</span><br><span class="line">     ^~~~~~~</span><br><span class="line">In file included from fileSystem.h:3,</span><br><span class="line">                 from main.c:3:</span><br><span class="line">fcb.h:43:5: note: previous declaration of ‘doWrite’ was here</span><br><span class="line"> int doWrite(fcb *Fcb, char content[]);</span><br><span class="line">     ^~~~~~~</span><br><span class="line">In file included from main.c:4:</span><br><span class="line">fcb.h:46:5: error: conflicting types for ‘addDirUnit’</span><br><span class="line"> int addDirUnit(dentryTable *dentryTable, char fileName[], int type, int fcbBlockNum) ;</span><br><span class="line">     ^~~~~~~~~~</span><br><span class="line">In file included from fileSystem.h:3,</span><br><span class="line">                 from main.c:3:</span><br><span class="line">fcb.h:46:5: note: previous declaration of ‘addDirUnit’ was here</span><br><span class="line"> int addDirUnit(dentryTable *dentryTable, char fileName[], int type, int fcbBlockNum) ;</span><br><span class="line">     ^~~~~~~~~~</span><br><span class="line">In file included from main.c:4:</span><br><span class="line">fcb.h:47:5: error: conflicting types for ‘doRead’</span><br><span class="line"> int doRead(fcb *FCB, int len);</span><br><span class="line">     ^~~~~~</span><br><span class="line">In file included from fileSystem.h:3,</span><br><span class="line">                 from main.c:3:</span><br><span class="line">fcb.h:47:5: note: previous declaration of ‘doRead’ was here</span><br><span class="line"> int doRead(fcb *FCB, int len);</span><br><span class="line">     ^~~~~~</span><br><span class="line">In file included from main.c:4:</span><br><span class="line">fcb.h:49:6: error: conflicting types for ‘findDentryIdx’</span><br><span class="line">  int findDentryIdx(dentryTable *dentryList, char dentryName[]);</span><br><span class="line">      ^~~~~~~~~~~~~</span><br><span class="line">In file included from fileSystem.h:3,</span><br><span class="line">                 from main.c:3:</span><br><span class="line">fcb.h:49:6: note: previous declaration of ‘findDentryIdx’ was here</span><br><span class="line">  int findDentryIdx(dentryTable *dentryList, char dentryName[]);</span><br><span class="line">      ^~~~~~~~~~~~~</span><br><span class="line">In file included from main.c:4:</span><br><span class="line">fcb.h:52:5: error: conflicting types for ‘deleteDirUnit’</span><br><span class="line"> int deleteDirUnit(dentryTable *dirtable, int idx);</span><br><span class="line">     ^~~~~~~~~~~~~</span><br><span class="line">In file included from fileSystem.h:3,</span><br><span class="line">                 from main.c:3:</span><br><span class="line">fcb.h:52:5: note: previous declaration of ‘deleteDirUnit’ was here</span><br><span class="line"> int deleteDirUnit(dentryTable *dirtable, int idx);</span><br><span class="line">     ^~~~~~~~~~~~~</span><br><span class="line">In file included from main.c:4:</span><br><span class="line">fcb.h:53:5: error: conflicting types for ‘deleteFileInTable’</span><br><span class="line"> int deleteFileInTable(dentryTable *dirTable, int unitIndx);</span><br><span class="line">     ^~~~~~~~~~~~~~~~~</span><br><span class="line">In file included from fileSystem.h:3,</span><br><span class="line">                 from main.c:3:</span><br><span class="line">fcb.h:53:5: note: previous declaration of ‘deleteFileInTable’ was here</span><br><span class="line"> int deleteFileInTable(dentryTable *dirTable, int unitIndx);</span><br><span class="line">     ^~~~~~~~~~~~~~~~~</span><br><span class="line">In file included from main.c:4:</span><br><span class="line">fcb.h:55:2: error: #endif without #if</span><br><span class="line"> #endif</span><br><span class="line">  ^~~~~</span><br><span class="line">fileSystem.c:1:8: error: expected ‘=’, ‘,’, ‘;’, ‘asm’ or ‘__attribute__’ before string constant</span><br><span class="line"> nclude &quot;fileSystem.h&quot;</span><br><span class="line">        ^~~~~~~~~~~~~~</span><br><span class="line">In file included from fileSystem.h:3,</span><br><span class="line">                 from fcb.h:4,</span><br><span class="line">                 from fileSystem.c:2:</span><br><span class="line">fcb.h:14:3: warning: data definition has no type or storage class</span><br><span class="line"> &#125; dentryUnit;</span><br><span class="line">   ^~~~~~~~~~</span><br><span class="line">fcb.h:14:3: warning: type defaults to ‘int’ in declaration of ‘dentryUnit’ [-Wimplicit-int]</span><br><span class="line">fcb.h:20:5: error: expected specifier-qualifier-list before ‘dentryUnit’</span><br><span class="line">     dentryUnit dentries[dentry_Max_SIZE]; //目录列表</span><br><span class="line">     ^~~~~~~~~~</span><br><span class="line">fcb.h:55:2: error: #endif without #if</span><br><span class="line"> #endif</span><br><span class="line">  ^~~~~</span><br><span class="line">In file included from fileSystem.c:2:</span><br><span class="line">fcb.h:14:3: error: ‘dentryUnit’ redeclared as different kind of symbol</span><br><span class="line"> &#125; dentryUnit;</span><br><span class="line">   ^~~~~~~~~~</span><br><span class="line">In file included from fileSystem.h:3,</span><br><span class="line">                 from fcb.h:4,</span><br><span class="line">                 from fileSystem.c:2:</span><br><span class="line">fcb.h:14:3: note: previous declaration of ‘dentryUnit’ was here</span><br><span class="line"> &#125; dentryUnit;</span><br><span class="line">   ^~~~~~~~~~</span><br><span class="line">In file included from fileSystem.c:2:</span><br><span class="line">fcb.h:17:16: error: redefinition of ‘struct dentry_list’</span><br><span class="line"> typedef struct dentry_list</span><br><span class="line">                ^~~~~~~~~~~</span><br><span class="line">In file included from fileSystem.h:3,</span><br><span class="line">                 from fcb.h:4,</span><br><span class="line">                 from fileSystem.c:2:</span><br><span class="line">fcb.h:17:16: note: originally defined here</span><br><span class="line"> typedef struct dentry_list</span><br><span class="line">                ^~~~~~~~~~~</span><br><span class="line">In file included from fileSystem.c:2:</span><br><span class="line">fcb.h:21:2: error: conflicting types for ‘dentryTable’</span><br><span class="line"> &#125;dentryTable;</span><br><span class="line">  ^~~~~~~~~~~</span><br><span class="line">In file included from fileSystem.h:3,</span><br><span class="line">                 from fcb.h:4,</span><br><span class="line">                 from fileSystem.c:2:</span><br><span class="line">fcb.h:21:2: note: previous declaration of ‘dentryTable’ was here</span><br><span class="line"> &#125;dentryTable;</span><br><span class="line">  ^~~~~~~~~~~</span><br><span class="line">In file included from fileSystem.c:2:</span><br><span class="line">fcb.h:23:16: error: redefinition of ‘struct FCB’</span><br><span class="line"> typedef struct FCB</span><br><span class="line">                ^~~</span><br><span class="line">In file included from fileSystem.h:3,</span><br><span class="line">                 from fcb.h:4,</span><br><span class="line">                 from fileSystem.c:2:</span><br><span class="line">fcb.h:23:16: note: originally defined here</span><br><span class="line"> typedef struct FCB</span><br><span class="line">                ^~~</span><br><span class="line">In file included from fileSystem.c:2:</span><br><span class="line">fcb.h:30:3: error: conflicting types for ‘fcb’</span><br><span class="line"> &#125; fcb;</span><br><span class="line">   ^~~</span><br><span class="line">In file included from fileSystem.h:3,</span><br><span class="line">                 from fcb.h:4,</span><br><span class="line">                 from fileSystem.c:2:</span><br><span class="line">fcb.h:30:3: note: previous declaration of ‘fcb’ was here</span><br><span class="line"> &#125; fcb;</span><br><span class="line">   ^~~</span><br><span class="line">In file included from fileSystem.c:2:</span><br><span class="line">fcb.h:43:5: error: conflicting types for ‘doWrite’</span><br><span class="line"> int doWrite(fcb *Fcb, char content[]);</span><br><span class="line">     ^~~~~~~</span><br><span class="line">In file included from fileSystem.h:3,</span><br><span class="line">                 from fcb.h:4,</span><br><span class="line">                 from fileSystem.c:2:</span><br><span class="line">fcb.h:43:5: note: previous declaration of ‘doWrite’ was here</span><br><span class="line"> int doWrite(fcb *Fcb, char content[]);</span><br><span class="line">     ^~~~~~~</span><br><span class="line">In file included from fileSystem.c:2:</span><br><span class="line">fcb.h:46:5: error: conflicting types for ‘addDirUnit’</span><br><span class="line"> int addDirUnit(dentryTable *dentryTable, char fileName[], int type, int fcbBlockNum) ;</span><br><span class="line">     ^~~~~~~~~~</span><br><span class="line">In file included from fileSystem.h:3,</span><br><span class="line">                 from fcb.h:4,</span><br><span class="line">                 from fileSystem.c:2:</span><br><span class="line">fcb.h:46:5: note: previous declaration of ‘addDirUnit’ was here</span><br><span class="line"> int addDirUnit(dentryTable *dentryTable, char fileName[], int type, int fcbBlockNum) ;</span><br><span class="line">     ^~~~~~~~~~</span><br><span class="line">In file included from fileSystem.c:2:</span><br><span class="line">fcb.h:47:5: error: conflicting types for ‘doRead’</span><br><span class="line"> int doRead(fcb *FCB, int len);</span><br><span class="line">     ^~~~~~</span><br><span class="line">In file included from fileSystem.h:3,</span><br><span class="line">                 from fcb.h:4,</span><br><span class="line">                 from fileSystem.c:2:</span><br><span class="line">fcb.h:47:5: note: previous declaration of ‘doRead’ was here</span><br><span class="line"> int doRead(fcb *FCB, int len);</span><br><span class="line">     ^~~~~~</span><br><span class="line">In file included from fileSystem.c:2:</span><br><span class="line">fcb.h:49:6: error: conflicting types for ‘findDentryIdx’</span><br><span class="line">  int findDentryIdx(dentryTable *dentryList, char dentryName[]);</span><br><span class="line">      ^~~~~~~~~~~~~</span><br><span class="line">In file included from fileSystem.h:3,</span><br><span class="line">                 from fcb.h:4,</span><br><span class="line">                 from fileSystem.c:2:</span><br><span class="line">fcb.h:49:6: note: previous declaration of ‘findDentryIdx’ was here</span><br><span class="line">  int findDentryIdx(dentryTable *dentryList, char dentryName[]);</span><br><span class="line">      ^~~~~~~~~~~~~</span><br><span class="line">In file included from fileSystem.c:2:</span><br><span class="line">fcb.h:52:5: error: conflicting types for ‘deleteDirUnit’</span><br><span class="line"> int deleteDirUnit(dentryTable *dirtable, int idx);</span><br><span class="line">     ^~~~~~~~~~~~~</span><br><span class="line">In file included from fileSystem.h:3,</span><br><span class="line">                 from fcb.h:4,</span><br><span class="line">                 from fileSystem.c:2:</span><br><span class="line">fcb.h:52:5: note: previous declaration of ‘deleteDirUnit’ was here</span><br><span class="line"> int deleteDirUnit(dentryTable *dirtable, int idx);</span><br><span class="line">     ^~~~~~~~~~~~~</span><br><span class="line">In file included from fileSystem.c:2:</span><br><span class="line">fcb.h:53:5: error: conflicting types for ‘deleteFileInTable’</span><br><span class="line"> int deleteFileInTable(dentryTable *dirTable, int unitIndx);</span><br><span class="line">     ^~~~~~~~~~~~~~~~~</span><br><span class="line">In file included from fileSystem.h:3,</span><br><span class="line">                 from fcb.h:4,</span><br><span class="line">                 from fileSystem.c:2:</span><br><span class="line">fcb.h:53:5: note: previous declaration of ‘deleteFileInTable’ was here</span><br><span class="line"> int deleteFileInTable(dentryTable *dirTable, int unitIndx);</span><br><span class="line">     ^~~~~~~~~~~~~~~~~</span><br><span class="line">In file included from fileSystem.c:2:</span><br><span class="line">fcb.h:55:2: error: #endif without #if</span><br><span class="line"> #endif</span><br><span class="line">  ^~~~~</span><br><span class="line">[root@chenlifeng FW]# vi fcb.h</span><br><span class="line">[root@chenlifeng FW]# less fcb.h</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ifndef FCB_H</span><br><span class="line">#define FCB_H</span><br><span class="line"></span><br><span class="line">#include &quot;fileSystem.h&quot;</span><br><span class="line">#define dentry_Max_SIZE   15</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 文件结构（文件可以是目录也可以是普通文件）</span><br><span class="line">typedef struct dentry</span><br><span class="line">&#123;</span><br><span class="line">    char fileName[59];</span><br><span class="line">    char type;</span><br><span class="line">    int startBlock;</span><br><span class="line">&#125; dentryUnit;</span><br><span class="line"></span><br><span class="line">// 文件表</span><br><span class="line">typedef struct dentry_list</span><br><span class="line">&#123;</span><br><span class="line">    int dentryAmount; //目录数目</span><br><span class="line">    dentryUnit dentries[dentry_Max_SIZE]; //目录列表</span><br><span class="line">&#125;dentryTable;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">typedef struct FCB</span><br><span class="line">&#123;</span><br><span class="line">    int blockIdx;  //文件数据起始的盘块号</span><br><span class="line">    int fileSize; //文件大小，单位为盘块号</span><br><span class="line">    int dataSize; //已写入的内容，以字节为单位</span><br><span class="line">    int readptr;</span><br><span class="line">    int linkCount;</span><br><span class="line">&#125; fcb;</span><br><span class="line"></span><br><span class="line">int touch(char fileName[], int fileSize);</span><br><span class="line">int rm(char fileName[]);</span><br><span class="line">int cd(char dirName[]) ;</span><br><span class="line">void ls() ;</span><br><span class="line">int rmdir(char dirName[]) ;</span><br><span class="line"></span><br><span class="line">int mkdir(char dirName[]) ;</span><br><span class="line">int read(char fileName[], int length);</span><br><span class="line">int write(char fileName [], char content[]);</span><br><span class="line">int mv(char oldName[], char newName[]);</span><br><span class="line">int deleteDir(char dirName[]);</span><br><span class="line">int doWrite(fcb *Fcb, char content[]);</span><br><span class="line">int createFcb(int fcbBlockNum, int fileBlockNum, int fileSize);</span><br><span class="line">// 添加一个目录项</span><br><span class="line">:</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>





<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">ifndef FCB_H</span><br><span class="line">#define FCB_H</span><br><span class="line"></span><br><span class="line">#include &quot;fileSystem.h&quot;</span><br><span class="line">#define dentry_Max_SIZE   15</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 文件结构（文件可以是目录也可以是普通文件）</span><br><span class="line">typedef struct dentry</span><br><span class="line">&#123;</span><br><span class="line">    char fileName[59];</span><br><span class="line">    char type;</span><br><span class="line">    int startBlock;</span><br><span class="line">&#125; dentryUnit;</span><br><span class="line"></span><br><span class="line">// 文件表</span><br><span class="line">typedef struct dentry_list</span><br><span class="line">&#123;</span><br><span class="line">    int dentryAmount; //目录数目</span><br><span class="line">    dentryUnit dentries[dentry_Max_SIZE]; //目录列表</span><br><span class="line">&#125;dentryTable;</span><br><span class="line"></span><br><span class="line">typedef struct FCB</span><br><span class="line">&#123;</span><br><span class="line">    int blockIdx;  //文件数据起始的盘块号</span><br><span class="line">    int fileSize; //文件大小，单位为盘块号</span><br><span class="line">    int dataSize; //已写入的内容，以字节为单位</span><br><span class="line">    int readptr;</span><br><span class="line">    int linkCount;</span><br><span class="line">&#125; fcb;</span><br><span class="line"></span><br><span class="line">int touch(char fileName[], int fileSize);</span><br><span class="line">int rm(char fileName[]);</span><br><span class="line">int cd(char dirName[]) ;</span><br><span class="line">void ls() ;</span><br><span class="line">int rmdir(char dirName[]) ;</span><br><span class="line"></span><br><span class="line">int mkdir(char dirName[]) ;</span><br><span class="line">int read(char fileName[], int length);</span><br><span class="line">int write(char fileName [], char content[]);</span><br><span class="line">int mv(char oldName[], char newName[]);</span><br><span class="line">int deleteDir(char dirName[]);</span><br><span class="line">int doWrite(fcb *Fcb, char content[]);</span><br><span class="line">int createFcb(int fcbBlockNum, int fileBlockNum, int fileSize);</span><br><span class="line">// 添加一个目录项</span><br><span class="line">int addDirUnit(dentryTable *dentryTable, char fileName[], int type, int fcbBlockNum) ;</span><br><span class="line">int doRead(fcb *FCB, int len);</span><br><span class="line">    //从目录中查找目录项</span><br><span class="line">int rmdir(char dirName[]) ;</span><br><span class="line"></span><br><span class="line">int mkdir(char dirName[]) ;</span><br><span class="line">int read(char fileName[], int length);</span><br><span class="line">int write(char fileName [], char content[]);</span><br><span class="line">int mv(char oldName[], char newName[]);</span><br><span class="line">int deleteDir(char dirName[]);</span><br><span class="line">int doWrite(fcb *Fcb, char content[]);</span><br><span class="line">int createFcb(int fcbBlockNum, int fileBlockNum, int fileSize);</span><br><span class="line">// 添加一个目录项</span><br><span class="line">int addDirUnit(dentryTable *dentryTable, char fileName[], int type, int fcbBlockNum) ;</span><br><span class="line">int doRead(fcb *FCB, int len);</span><br><span class="line">    //从目录中查找目录项</span><br><span class="line"> int findDentryIdx(dentryTable *dentryList, char dentryName[]);</span><br><span class="line">int releaseFile(int fcbBlock);</span><br><span class="line">//删除目录项</span><br><span class="line">int deleteDirUnit(dentryTable *dirtable, int idx);</span><br><span class="line">int deleteFileInTable(dentryTable *dirTable, int unitIndx);</span><br><span class="line"></span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>




      
    </div>
    <footer class="article-footer">
      <a data-url="https://wingchi-leung.github.io/goat-iceam.github.io/2021/07/26/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/" data-id="ckrjzlslr0001kwu1e0b9429j" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/goat-iceam.github.io/2021/07/17/hello-world/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Hello World</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/goat-iceam.github.io/archives/2021/07/">July 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/goat-iceam.github.io/2021/07/26/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/">(no title)</a>
          </li>
        
          <li>
            <a href="/goat-iceam.github.io/2021/07/17/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/goat-iceam.github.io/" class="mobile-nav-link">Home</a>
  
    <a href="/goat-iceam.github.io/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/goat-iceam.github.io/js/jquery-3.4.1.min.js"></script>



  
<script src="/goat-iceam.github.io/fancybox/jquery.fancybox.min.js"></script>




<script src="/goat-iceam.github.io/js/script.js"></script>





  </div>
</body>
</html>